# Todo app Next.js

## Declarative Seeding with Snaplet seed

### What's This All About?

In this post, we'll dive into the fundamentals of `@snaplet/seed`. Our tool aims to redefine seed script writing—making it declarative, minimalistic, and maintainable. We use Typescript, a language beloved by many developers. By the end, you'll not only be equipped to integrate `@snaplet/seed` into your stack for enhanced dev environments but also appreciate how it streamlines and accelerates seed script creation.

### Our Approach

We'll use a simple todo app as our example (source code available [here](https://github.com/avallete/todonextjs). Through this, we'll explore a typical development scenario, demonstrating the utility of `@snaplet/seed`.

### Prerequisites

Before running this project, you will need the following installed on your system:

- Node.js
- npm
- PostgreSQL (either local or remote)

### Getting Started

1. `git clone git@github.com:snaplet/examples.git && cd examples/seed/todonextapp`
2. `npm install`
3. Edit `DATABASE_URL` in `.env` to make it match your PostgreSQL database.
4. Deploy the prisma model to our local database with: `npx prisma db push --force-reset`
5. Run the app with `npm run dev`

### Starting Simple:

First, we'll build a basic todo app with a single table, using Prisma for schema definition:

```ts
model todo {
  id         Int      @id @default(autoincrement())
  text       String
  completed  Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamp(6)
}
```

Here's what the database ERD looks like:

https://github.com/avallete/todonextjs/assets/8771783/097fce2f-9732-412e-bd30-d3cc76d96504

With a straightforward interface and typical CRUD endpoints, our app quickly comes to life:

https://github.com/avallete/todonextjs/assets/8771783/5896b6a7-7bb1-4bf1-8a85-b125c0177a83

Imagine wanting to create numerous todos to test various functionalities. This is where diverse approaches come into play—some prefer seed classes for each model, others lean towards straightforward SQL or TS scripts. Let's introduce another method: `@snaplet/seed`.

Here's how `snaplet` operates:

1. **Introspection:** It analyzes your database, gathering schema, data, and relationship details via `snaplet setup`.
2. **Configuration:** You receive a `seeds.mts` file, where you can declaratively specify your desired data creation. `snaplet` then utilizes the information from the introspection phase.

Setting it up is as simple as:

```bash
npx --yes snaplet@latest setup 
```

Select the option 1 "I want to generate seed data" and provide your database URL when prompted.

This process generates a `seed.mts` file:
```ts
import { createSeedClient } from '@snaplet/seed';

// You can use @snaplet/copycat to generate fake data for a field, for example:
// ```
// await seed.users([{ email: ({ seed }) => copycat.email(seed) }])
// ```
// More on this in our docs: https://docs.snaplet.dev/core-concepts/seed#inside-the-snapletseed-workflow
import { copycat } from '@snaplet/copycat'

// This is a basic example generated by Snaplet to start you off, check out the docs for where to go from here
// * For more on getting started with @snaplet/seed: https://docs.snaplet.dev/getting-started/quick-start/seed
// * For a more detailed reference: https://docs.snaplet.dev/core-concepts/seed


const seed = await createSeedClient({
  dryRun: process.env.DRY !== '0',
});

// Clears all existing data in the database, but keep the structure
await seed.$resetDatabase()


// This will create 3 records in the todos table
// it reads todos times(x) 3
await seed.todos(x => x(3))

// Run it with: DRY=0 npx tsx seed.mts
```

[![asciicast](https://asciinema.org/a/63LZrysbUuEbd8GSGQhbtXNrU.svg)](https://asciinema.org/a/63LZrysbUuEbd8GSGQhbtXNrU)

To create our desired 20 todos, we modify the `snaplet.todo` line accordingly:

```ts
// x stand for the algebric "times" operator
// So this read like "create a todo x 20"
await seed.todo((x) => x(20));
```
Populating the database is then just a command away:

```bash
DRY=0 npx tsx seed.mts
```

And voila !

![todolist](https://github.com/avallete/todonextjs/assets/8771783/e1ecf3b9-7cd8-41c2-a7e4-84c36c1f5fbc)

Running `npx tsx seed.mts` reveals the underlying SQL queries, showcasing the simplicity and power of `snaplet generate`:

```sql
INSERT INTO
  public.todo (id, text, completed, created_at)
VALUES
  (
    1,
    'Maledatio de quam conventorquean im perspecta genus.',
    DEFAULT,
    DEFAULT
  ),
  (
    2,
    'Eturus quod probo cum valla cum videret.',
    DEFAULT,
    DEFAULT
  ),
  (
    3,
    'Faciendum quosvis quo apudinum pertur vult.',
    DEFAULT,
    DEFAULT
  ),
  ...
  (
    20,
    'Nobis ad placet esset quod inflammater sed.',
    DEFAULT,
    DEFAULT
  );

SELECT
  setval(
    '"public"."todo_id_seq"'::regclass,
    (
      SELECT
        MAX("id")
      FROM
        "public"."todo"
    )
  );
```

### Adapting to Changes:

As with any project, requirements evolve. Let's say our app now needs:

1. Each todo linked to a user.
2. Todos with upvote/downvote capabilities.

Let's update our `schema.prisma` accordingly:

```ts
model user {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  created_at DateTime @default(now()) @db.Timestamp(6)
  todos     todo[]
  votes     vote[]
}

model todo {
  id         Int      @id @default(autoincrement())
  text       String
  completed  Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamp(6)
  created_by_id Int
  created_by user     @relation(fields: [created_by_id], references: [id])
  votes      vote[]
}

enum vote_value {
  UPVOTE
  DOWNVOTE
}

model vote {
  id        Int      @id @default(autoincrement())
  todo_id   Int
  todo      todo     @relation(fields: [todo_id], references: [id])
  value     vote_value @default(UPVOTE)
  created_at DateTime @default(now()) @db.Timestamp(6)
  created_by_id Int
  created_by user     @relation(fields: [created_by_id], references: [id])
}
```

Let's deploy this new schema to our database:

```bash
# Generate a migration file           # Reset our local database schema    # Regenerate prisma client 
npx prisma migrate dev --create-only && npx prisma db push --force-reset && npx prisma generate
```

Then we can adapt our UI and api to reflect these changes by uncommenting the following lines:
- `types.ts` (line 7-8)
- `pages/index.tsx` (line 193-196)
- `pages/api/todo.ts` (line 20-56)
- `pages/search.ts` (line 27-50)


Our updated ERD schema:

https://github.com/avallete/todonextjs/assets/8771783/06156217-8c3c-4ad1-a949-1a3e6cd434e3

Now we want to re-introspect our database with `snaplet` to update our types with new values. We can do so by re-running our setup:
```bash
npx snaplet setup && npx snaplet generate
```

For development, we now want:

1. Five users.
2. Twenty todos created by these users.
3. Five votes per todo.

With `snaplet`, our `seed.mts` changes to:
```ts
import { createSeedClient } from "@snaplet/seed";

// You can use @snaplet/copycat to generate fake data for a field, for example:
// ```
// await seed.users([{ email: ({ seed }) => copycat.email(seed) }])
// ```
// More on this in our docs: https://docs.snaplet.dev/core-concepts/seed#inside-the-snapletseed-workflow
import { copycat } from "@snaplet/copycat";

// This is a basic example generated by Snaplet to start you off, check out the docs for where to go from here
// * For more on getting started with @snaplet/seed: https://docs.snaplet.dev/getting-started/quick-start/seed
// * For a more detailed reference: https://docs.snaplet.dev/core-concepts/seed

const seed = await createSeedClient({
  dryRun: process.env.DRY !== "0",
});

// Clears all existing data in the database, but keep the structure
await seed.$resetDatabase();

// 1. We create our first 5 initials users
const appPlan = await seed.users((x) => x(5));

// 2. We create our 20 todos, 
await seed.todos(
  (x) =>
    x(20, () => ({
      votes: (x) =>
        x(
          // 3. For each todo, we want to create 5 votes
          5,
          () => ({
            // 4. Each vote value should be either an upvote or a downvote
            value: ({ seed }) =>
              copycat.oneOf(seed, ["UPVOTE" as const, "DOWNVOTE" as const]),
          })
        ),
    })),
  // 5. We use connect to ensure that those 20 todos will be connected to the pool of users we already created before
  { connect: { users: appPlan.users } }
);

// Run it with: DRY=0 npx tsx seed.mts
```

We can now seed our database with:

```bash
DRY=0 npx tsx seed.mts
```

This comprehensive approach saves us from maintaining a lengthy and complex seed script (the generated SQL is now 120 lines long), illustrating why at Snaplet, we advocate for a declarative, database-aware, and auto-filled methodology. It's about creating and maintaining a dynamic, production-like development environment with ease.

### Introduce snaplet to E2E testing

Now, we have a convenient way to add data to our app. But what we really want is to ensure that this data is displayed properly by our interface, and that we can interact with it as wanted.
To do this, one of the way is E2E testing, as it'll cover the whole pipeline between your data and your user and won't rely on your implementation, just on the behaviour.

Here let's write 2 basics E2E tests that would ensure that:

1. When a todo is not "finished" we can check it to mark it as "finished", the interface should reflect that
2. Whant a todo is "finished" we can check it out, and it should be back in the "todo items" section

If you think about this, those two E2E tests, will already cover a whole bunch of our app behaviours and implementation, in 2 tests you can check:
1. That your UI allow the user to perform the action
2. That your API properly pass the action to the database
3. That your database properly save the user change
4. That your UI update to show the change to the user

And by using `@snaplet/seed` rather than a handmade seeding script, you can declare and seed only the data that you care about in your test.

So let's dig in, as a first we'll add [cypress](https://www.cypress.io/) E2E testing framework in our app.

To do so, let's run and follow the [cypress onboarding docs](https://docs.cypress.io/guides/overview/why-cypress):

```
npm install cypress --save-dev
```

Then we configure cypress for our project by following their onboarding:

```
./node_modules/.bin/cypress open
```

Then we can write a cypress test file `actions-on-todo.cy.ts` and put the following content in it:

```ts
import { createSeedClient } from "@snaplet/seed";

describe('todos actions tests', () => {
  it('can mark a unfinished todo as finished', async () => {
    // 1. We create a new seed client
    const seed = await createSeedClient({
      dryRun: false
    });
    // 2. We reset the database for it
    await seed.$resetDatabase()
    // 3. We create a single todo in our app with an "unfinished" status
    await seed.todos((x) => x(1, () => ({
      completed: false,
      text: 'can mark a unfinished todo as finished'
    })))
    cy.visit('localhost:3000')
  })
})
```


### Conclusion

In our exploration of `@snaplet/seed`, we've seen its capability in simplifying the creation and maintenance of seed scripts, particularly as your project requirements evolve. It stands as a robust tool in your development toolkit, adapting seamlessly to changes and enhancements in your project.

For a comprehensive understanding of all the features, our [seed documentation](https://docs.snaplet.dev/core-concepts/seed) is an invaluable resource. It covers everything you need to know to make the most out of `seed`.

We also highly value community engagement and feedback. If you have any use cases, questions, or suggestions about `seed`, we would love to hear from you. Join our conversation on our [Discord Server](https://discord.gg/traBYqnysU).
Let's make generate not just a tool, but a community-driven powerhouse.

Happy seeding, and see you on Discord!

---

### Acknowledgment

The foundation for this tutorial was David Li's blog post, which I've expanded upon to demonstrate the enhanced developer experience with `snaplet seed`: [David Li's Original Post](https://friendlyuser.github.io/posts/tech/js/nextjs_todo_list_neon/).